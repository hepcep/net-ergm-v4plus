
R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

- Project '/oscar/home/akhann16/code/net-ergm-v4plus' loaded. [renv 1.0.7]
> # Process the synthetic dataset with 32K nodes to enable ERGM fitting
> 
> rm(list=ls())
> 
> 
> # Activate R environment ------------------------------
> 
> library(renv)

Attaching package: ‘renv’

The following objects are masked from ‘package:stats’:

    embed, update

The following objects are masked from ‘package:utils’:

    history, upgrade

The following objects are masked from ‘package:base’:

    autoload, load, remove, use

> renv::activate()
> 
> 
> # Libraries ------------------------------ 
> 
> library(network)

‘network’ 1.18.2 (2023-12-04), part of the Statnet Project
* ‘news(package="network")’ for changes since last version
* ‘citation("network")’ for citation information
* ‘https://statnet.org’ for help, support, and other information

> library(ergm)

‘ergm’ 4.6.0 (2023-12-17), part of the Statnet Project
* ‘news(package="ergm")’ for changes since last version
* ‘citation("ergm")’ for citation information
* ‘https://statnet.org’ for help, support, and other information

‘ergm’ 4 is a major update that introduces some backwards-incompatible
changes. Please type ‘news(package="ergm")’ for a list of major
changes.

> library(dplyr)

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

> library(ergm.userterms)
Loading required package: statnet.common

Attaching package: ‘statnet.common’

The following objects are masked from ‘package:base’:

    attr, order


‘ergm.userterms’ 3.1.1 (2020-02-01), part of the Statnet Project
* ‘news(package="ergm.userterms")’ for changes since last version
* ‘citation("ergm.userterms")’ for citation information
* ‘https://statnet.org’ for help, support, and other information

NOTE: If you use custom ERGM terms based on ‘ergm.userterms’ version
prior to 3.1, you will need to perform a one-time update of the package
boilerplate files (the files that you did not write or modify) from
‘ergm.userterms’ 3.1 or later. See help('eut-upgrade') for
instructions.

> library(here)
here() starts at /oscar/home/akhann16/code/net-ergm-v4plus
> 
> # Read Synthpop Data ------------------------------ 
> 
> data_path <- here("data", "synthpop-2023-10-12 12_01_32.csv")
> data <- read.csv(data_path, header=TRUE)
> glimpse(data)
Rows: 32,002
Columns: 15
$ sex                       <chr> "M", "M", "M", "M", "M", "M", "M", "M", "M",…
$ race                      <chr> "Wh", "Wh", "Wh", "Wh", "Wh", "Wh", "Wh", "W…
$ agecat                    <chr> "18-24", "18-24", "18-24", "18-24", "18-24",…
$ age_started               <int> 18, 19, 16, 19, 5, 19, 15, 17, 25, 18, 21, 1…
$ fraction_recept_sharing   <dbl> 1.00, 0.10, 0.10, 0.00, 0.00, 0.00, 0.25, 0.…
$ syringe_source            <int> 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,…
$ daily_injection_intensity <chr> "once or twice a day", "once or twice a day"…
$ age_lb                    <int> 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, …
$ age_ub                    <int> 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, …
$ age                       <int> 23, 21, 19, 20, 21, 21, 21, 21, 25, 18, 24, …
$ zipcode                   <int> 60644, 60644, 60644, 60644, 60644, 60644, 60…
$ Zip                       <int> 60644, 60644, 60644, 60644, 60644, 60644, 60…
$ lon                       <dbl> -87.76885, -87.77289, -87.76898, -87.76998, …
$ lat                       <dbl> 41.88311, 41.88240, 41.86867, 41.89144, 41.8…
$ hcv_status                <chr> "sucseptible", "sucseptible", "sucseptible",…
> 
> # Input  In/Outdegree Data (Specified per January 23, 2025) ------------------------------
> ## https://anl.box.com/s/01zwyn331jquyps4os0cirtopczes39m
> 
> indegree_data <- read.table(text = "
+   in_degree lower_nbprob lower_n mean_nbprob mean_n upper_nbprob upper_n
+   0 0.5821942 18630.21 0.64583354 20666.67 0.70507399 22562.37 
+   1 0.17457059 5586.26 0.2031094 6499.50 0.23448797 7503.62
+   2 0.0669945 2143.82 0.083 2657.25 0.10152704 3248.87
+   3 0.02875131 920.04 0.0366 1169.96 0.04498079 1439.39
+   4 0.01299143 415.73 0.0167 533.52 0.02015486 644.96
+   5 0.00604716 193.51 0.00776 248.32 0.00909181 290.94
+   6 0.00286968 91.83 0.00366 117.14 0.00411961 131.83
+   7 0.00138042 44.17 0.00174 55.79 0.00187257 59.92
+   8 0.00067075 21.46 0.000836 26.76 0.0008532 27.30
+   9 0.00032845 10.51 0.000403 12.90 0.00038946 12.46
+   10 0.00016183 5.18 0.000195 6.25 0.00017804 5.70
+   11 0.00008014 2.56 0.0000949 3.04 0.00008149 2.61
+   12 0.00003985 1.28 0.0000463 1.48 0.00003733 1.19
+   13 0.00001988 0.64 0.0000226 0.72 0.00001712 0.55
+   14 0.00000995 0.32 0.0000111 0.35 0.00000785 0.25
+   15 0.00000499 0.16 0.00000543 0.17 0.00000361 0.12
+   16 0.00000251 0.08 0.00000267 0.09 0.00000166 0.05
+   17 0.00000127 0.04 0.00000131 0.04 0.00000076 0.02
+   18 0.00000064 0.02 0.00000065 0.02 0.00000035 0.01
+   19 0.00000032 0.01 0.00000032 0.01 0.00000016 0.01
+   20 0.00000016 0.01 0.00000016 0.01 0.00000007 0.00
+   ", 
+   header = TRUE)
> 
>   # Print the data frame to check
>   print(indegree_data)
   in_degree lower_nbprob  lower_n mean_nbprob   mean_n upper_nbprob  upper_n
1          0   0.58219420 18630.21  0.64583354 20666.67   0.70507399 22562.37
2          1   0.17457059  5586.26  0.20310940  6499.50   0.23448797  7503.62
3          2   0.06699450  2143.82  0.08300000  2657.25   0.10152704  3248.87
4          3   0.02875131   920.04  0.03660000  1169.96   0.04498079  1439.39
5          4   0.01299143   415.73  0.01670000   533.52   0.02015486   644.96
6          5   0.00604716   193.51  0.00776000   248.32   0.00909181   290.94
7          6   0.00286968    91.83  0.00366000   117.14   0.00411961   131.83
8          7   0.00138042    44.17  0.00174000    55.79   0.00187257    59.92
9          8   0.00067075    21.46  0.00083600    26.76   0.00085320    27.30
10         9   0.00032845    10.51  0.00040300    12.90   0.00038946    12.46
11        10   0.00016183     5.18  0.00019500     6.25   0.00017804     5.70
12        11   0.00008014     2.56  0.00009490     3.04   0.00008149     2.61
13        12   0.00003985     1.28  0.00004630     1.48   0.00003733     1.19
14        13   0.00001988     0.64  0.00002260     0.72   0.00001712     0.55
15        14   0.00000995     0.32  0.00001110     0.35   0.00000785     0.25
16        15   0.00000499     0.16  0.00000543     0.17   0.00000361     0.12
17        16   0.00000251     0.08  0.00000267     0.09   0.00000166     0.05
18        17   0.00000127     0.04  0.00000131     0.04   0.00000076     0.02
19        18   0.00000064     0.02  0.00000065     0.02   0.00000035     0.01
20        19   0.00000032     0.01  0.00000032     0.01   0.00000016     0.01
21        20   0.00000016     0.01  0.00000016     0.01   0.00000007     0.00
> 
> outdegree_data <- read.table(text = "
+   out_degree lower_nbprob lower_n mean_nbprob mean_n upper_nbprob upper_n
+   0 0.54372877 17399.32 0.60585013 19387.20 0.65685532 21019.37
+   1 0.18338748 5868.40 0.20216566 6469.30 0.22882848 7322.51
+   2 0.07935995 2539.52 0.0928 2968.26 0.11074794 3543.93
+   3 0.03840462 1228.95 0.0464 1485.72 0.05592998 1789.76
+   4 0.01956799 626.18 0.0242 774.64 0.02883424 922.70
+   5 0.0102708 328.67 0.0129 413.58 0.01504728 481.51
+   6 0.00549605 175.87 0.00701 224.26 0.00791582 253.31
+   7 0.0029812 95.40 0.00384 122.94 0.00418801 134.02
+   8 0.00163343 52.27 0.00212 67.95 0.00222519 71.21
+   9 0.00090194 28.86 0.00118 37.79 0.0011862 37.96
+   10 0.00050111 16.04 0.00066 21.12 0.000634 20.29
+   11 0.00027981 8.95 0.00037 11.85 0.00033959 10.87
+   12 0.00015689 5.02 0.000209 6.67 0.00018222 5.83
+   13 0.00008828 2.82 0.000118 3.77 0.00009792 3.13
+   14 0.00004982 1.59 0.0000667 2.13 0.00005269 1.69
+   15 0.00002819 0.90 0.0000378 1.21 0.00002838 0.91
+   16 0.00001599 0.51 0.0000215 0.69 0.00001531 0.49
+   17 0.00000908 0.29 0.0000122 0.39 0.00000826 0.26
+   18 0.00000517 0.17 0.00000698 0.22 0.00000446 0.14
+   19 0.00000295 0.09 0.00000398 0.13 0.00000241 0.08
+   20 0.00000168 0.05 0.00000228 0.07 0.0000013 0.04
+   ", 
+ header = TRUE)
> 
>   # Print the data frame to check
>   print(outdegree_data)
   out_degree lower_nbprob  lower_n mean_nbprob   mean_n upper_nbprob  upper_n
1           0   0.54372877 17399.32  0.60585013 19387.20   0.65685532 21019.37
2           1   0.18338748  5868.40  0.20216566  6469.30   0.22882848  7322.51
3           2   0.07935995  2539.52  0.09280000  2968.26   0.11074794  3543.93
4           3   0.03840462  1228.95  0.04640000  1485.72   0.05592998  1789.76
5           4   0.01956799   626.18  0.02420000   774.64   0.02883424   922.70
6           5   0.01027080   328.67  0.01290000   413.58   0.01504728   481.51
7           6   0.00549605   175.87  0.00701000   224.26   0.00791582   253.31
8           7   0.00298120    95.40  0.00384000   122.94   0.00418801   134.02
9           8   0.00163343    52.27  0.00212000    67.95   0.00222519    71.21
10          9   0.00090194    28.86  0.00118000    37.79   0.00118620    37.96
11         10   0.00050111    16.04  0.00066000    21.12   0.00063400    20.29
12         11   0.00027981     8.95  0.00037000    11.85   0.00033959    10.87
13         12   0.00015689     5.02  0.00020900     6.67   0.00018222     5.83
14         13   0.00008828     2.82  0.00011800     3.77   0.00009792     3.13
15         14   0.00004982     1.59  0.00006670     2.13   0.00005269     1.69
16         15   0.00002819     0.90  0.00003780     1.21   0.00002838     0.91
17         16   0.00001599     0.51  0.00002150     0.69   0.00001531     0.49
18         17   0.00000908     0.29  0.00001220     0.39   0.00000826     0.26
19         18   0.00000517     0.17  0.00000698     0.22   0.00000446     0.14
20         19   0.00000295     0.09  0.00000398     0.13   0.00000241     0.08
21         20   0.00000168     0.05  0.00000228     0.07   0.00000130     0.04
> 
> 
> 
> # Initialize network ----------
> 
> n <- nrow(data)
> n0 <- network.initialize(n = n, directed = TRUE)
> 
> 
> # Compute target number of edges ----------
> 
> inedges_target <- sum(indegree_data$in_degree * indegree_data$mean_n)
> outedges_target <- sum(outdegree_data$out_degree * outdegree_data$mean_n)
> edges_target <- mean(c(inedges_target, outedges_target))
> 
> inedges_target
[1] 20256.49
> outedges_target
[1] 25663.36
> edges_target
[1] 22959.93
> 
> 
> # Assign vertex attributes to the network ----------
> 
> synthpop_cols <- colnames(data)
> set.vertex.attribute(n0, colnames(data), data)
> 
> 
> # Test assignment between `n0` vertex attributes and `synthpop_cols` ----------
> 
> ## For sex variable
> identical(n0%v%"sex", data$sex)
[1] TRUE
> table(n0%v%"sex", exclude=NULL)

    F     M 
12573 19429 
> 
> ## For all variables:
> ### get vertex attribute names from the n0 graph object
> vertex_attr_names <- list.vertex.attributes(n0)
> 
> # define a function to check if a vertex attribute is identical to the corresponding column in data
> check_identical <- function(attr_name) {
+   graph_attr <- n0 %v% attr_name
+   data_attr <- data[[attr_name]]
+   
+   return(identical(graph_attr, data_attr))
+ }
> 
> ### use sapply() to apply the check_identical() function to all vertex attribute names
> identical_results <- sapply(vertex_attr_names, check_identical)
> 
> ### print the results
> print(identical_results)
                      age                    age_lb               age_started 
                     TRUE                      TRUE                      TRUE 
                   age_ub                    agecat daily_injection_intensity 
                     TRUE                      TRUE                      TRUE 
  fraction_recept_sharing                hcv_status                       lat 
                     TRUE                      TRUE                      TRUE 
                      lon                        na                      race 
                     TRUE                     FALSE                      TRUE 
                      sex            syringe_source              vertex.names 
                     TRUE                      TRUE                     FALSE 
                      Zip                   zipcode 
                     TRUE                      TRUE 
> 
> ### check if any values other than 'vertex.names' are FALSE
> if (any(identical_results[!(names(identical_results) %in% c("vertex.names", "na"))] == FALSE)) {
+   stop("Error: Some vertex attributes do not match the corresponding columns in data.")
+ } else {
+   cat("Test passed: All relevant vertex attributes match the corresponding columns in data.\n")
+ }
Test passed: All relevant vertex attributes match the corresponding columns in data.
> 
> 
> # Recode to add new variables to dataset ------------------------------
> 
> # young (< 26, to be set = 1) vs old (>= 26, to be set = 0) 
> age.cat <- n0 %v% "age"
> age.cat.df <- as.data.frame(age.cat)
> age.cat.df <-  
+   mutate(age.cat, young = ifelse(age.cat <26, 1, 0), .data = age.cat.df)
> xtabs(~age.cat+young, data = age.cat.df)
       young
age.cat    0    1
     18    0  471
     19    0  695
     20    0  854
     21    0 1053
     22    0 1142
     23    0 1286
     24    0 1561
     25    0  739
     26  787    0
     27  910    0
     28  946    0
     29 1018    0
     30 1024    0
     31 1027    0
     32 1119    0
     33 1110    0
     34 1117    0
     35  576    0
     36  585    0
     37  584    0
     38  617    0
     39  611    0
     40  676    0
     41  670    0
     42  732    0
     43  727    0
     44  719    0
     45  240    0
     46  232    0
     47  261    0
     48  253    0
     49  238    0
     50  225    0
     51  228    0
     52  233    0
     53  250    0
     54  235    0
     55  224    0
     56  231    0
     57  225    0
     58  269    0
     59  230    0
     60  258    0
     61  238    0
     62  245    0
     63  251    0
     64  252    0
     65  253    0
     66  212    0
     67  258    0
     68  231    0
     69  238    0
     70  229    0
     71  235    0
     72  219    0
     73  243    0
     74  263    0
     75  271    0
     76  243    0
     77  213    0
     78  256    0
     79  240    0
     80  224    0
> 
> # recode race variable to set ordering of categories
> race <- n0 %v% "race"
> race.num <- recode(race, 
+                    Wh = 1, Bl = 2,
+                    Hi = 3, Ot = 4)
> 
> # Initialize network and add attributes ----------
> 
> n0 %v% "young" <- age.cat.df$young
> n0 %v% "race.num" <- race.num
> 
> 
> # Generate target statistics from meta-mixing data ----------
>   ## Update with values meta mixing values from 10/17/2024
>   ## See https://anl.box.com/s/jrf5usly4ujuv3gagmdxlwxaiuvnlq1o
>   ## All network mixing parameters with CIs: https://anl.box.com/s/jg6y221hcbql1sd9kvsxpq0cei03qlr0 (Dec 5, 2024)
> 
> ## gender 
> ### mixing information from meta-analysis of sathcap AND socnet
> edges.male.end <- 0.60
> edges.female.end <- 0.38
> 
> male.pctmale <- 0.55
> male.pctfemale <- 0.44
> female.pctmale <- 0.72
> female.pctfemale <- 0.28
> 
> ### set gender targets 
> tgt.male.pctmale <- edges_target*edges.male.end*male.pctmale
> tgt.male.pctfemale <- edges_target*edges.male.end*male.pctfemale
> tgt.female.pctmale <- edges_target*edges.female.end*female.pctmale  
> tgt.female.pctfemale <- edges_target*edges.female.end*female.pctfemale
> 
> ## young (1=young; 0=old)
> ### mixing information from meta-analysis of sathcap AND socnet
> edges.young.end <- 0.16
> edges.old.end <- 0.84
>   
> young.pctyoung <- 048
> young.pctold <- 0.52
> old.pctyoung <- 0.10
> old.pctold <- 0.90
>  
> ## set young targets from meta data
> tgt.young.pctyoung <- edges_target * edges.young.end * young.pctyoung
> tgt.young.pctold <- edges_target * edges.young.end * young.pctold
> tgt.old.pctyoung <- edges_target * edges.old.end * old.pctyoung
> tgt.old.pctold <- edges_target * edges.old.end * old.pctold
> 
> 
> 
> ## race (1=white, 2=black, 3=hispanic, 4=other)
> 
> table(n0 %v% "race")

   Bl    Hi    Ot    Wh 
 8317  6853  1429 15403 
> table(n0 %v% "race.num", exclude=NULL) # will be sorted as per 1=W, 2=B, 3=H, 4=O

    1     2     3     4 
15403  8317  6853  1429 
> 
> 
> pct_to_white	<- 0.59
> pct_to_black	<- 0.18
> pct_to_hispanic	<- 0.17
> pct_to_other	<- 0.03
> 
> race.w.w <- 0.758 # (marks sum to 1, i.e., sum of all race.w.* = 1, sum of all race.b.* = 1)
> race.b.w <- 0.333 #-
> race.h.w <- 0.345 ##
> race.o.w <- 0.638 #--
> race.w.b <- 0.091 #
> race.b.b <- 0.495 #-
> race.h.b <- 0.011 ##
> race.o.b <- 0.106 #--
> race.w.h <- 0.111 #
> race.b.h <- 0.161 #-
> race.h.h <- 0.632 ##
> race.o.h <- 0.202 #--
> race.w.o <- 0.040 #
> race.b.o <- 0.011 #-
> race.h.o <- 0.011 ##
> race.o.o <- 0.053 #--
> 
> target.w.w <- edges_target * pct_to_white * race.w.w
> target.b.w <- edges_target * pct_to_white * race.b.w
> target.h.w <- edges_target * pct_to_white * race.h.w
> target.o.w <- edges_target * pct_to_white * race.o.w
> 
> target.w.b <- edges_target * pct_to_black * race.w.b
> target.b.b <- edges_target * pct_to_black * race.b.b
> target.h.b <- edges_target * pct_to_black * race.h.b
> target.o.b <- edges_target * pct_to_black * race.o.b
> 
> target.w.h <- edges_target * pct_to_hispanic * race.w.h
> target.b.h <- edges_target * pct_to_hispanic * race.b.h
> target.h.h <- edges_target * pct_to_hispanic * race.h.h
> target.o.h <- edges_target * pct_to_hispanic * race.o.h
> 
> target.w.o <- edges_target * pct_to_other * race.w.o
> target.b.o <- edges_target * pct_to_other * race.b.o
> target.h.o <- edges_target * pct_to_other * race.h.o
> target.o.o <- edges_target * pct_to_other * race.o.o
> 
> target_race_num  <- c(
+             target.b.w, target.h.w, target.o.w,
+   target.w.b, target.b.b, target.h.b, target.o.b,
+   target.w.h, target.b.h, target.h.h, target.o.h,
+   target.w.o, target.b.o, target.h.o, target.o.o
+ )
> 
> target_race_num
 [1] 4510.936465 4673.492734 8642.574969  376.083572 2045.729317   45.460651
 [7]  438.075369  433.253785  628.413147 2466.814342  788.443825   27.551910
[13]    7.576775    7.576775   36.506281
> 
> # Fit network only with edges ----------
> fit_edges_only_net <- 
+   ergm(
+     n0 ~
+       edges,
+     target.stats = edges_target,
+     eval.loglik = FALSE    
+     )
Unable to match target stats. Using MCMLE estimation.
Starting maximum pseudolikelihood estimation (MPLE):
Obtaining the responsible dyads.
Evaluating the predictor and response matrix.
Maximizing the pseudolikelihood.
Finished MPLE.
Starting Monte Carlo maximum likelihood estimation (MCMLE):
Iteration 1 of at most 60:
Optimizing with step length 1.0000.
The log-likelihood improved by 0.0476.
Convergence test p-value: 0.0082. Converged with 99% confidence.
Finished MCMLE.
This model was fit using MCMC.  To examine model diagnostics and check
for degeneracy, use the mcmc.diagnostics() function.
> 
> edges_only_net <- simulate(fit_edges_only_net, nsim=1)
> 
> # Test alignment of race_num ----------
> 
>   # Define the known mapping
>   num_to_race <- c("Wh", "Bl", "Hi", "Ot")  # 1=Wh,2=Bl,3=Hi,4=Ot
> 
>   # Retrieve the summaries
>   race_num_alignment <- summary(edges_only_net ~ nodemix("race.num", levels2 = -1))
>   race_term_alignment <- summary(edges_only_net ~ nodemix("race", levels2 = -1))
> 
>   # Print them for reference
>   print(race_num_alignment)
mix.race.num.2.1 mix.race.num.3.1 mix.race.num.4.1 mix.race.num.1.2 
            2906             2371              515             2883 
mix.race.num.2.2 mix.race.num.3.2 mix.race.num.4.2 mix.race.num.1.3 
            1594             1296              271             2463 
mix.race.num.2.3 mix.race.num.3.3 mix.race.num.4.3 mix.race.num.1.4 
            1253             1078              248              507 
mix.race.num.2.4 mix.race.num.3.4 mix.race.num.4.4 
             253              220               56 
>   print(race_term_alignment)
mix.race.Hi.Bl mix.race.Ot.Bl mix.race.Wh.Bl mix.race.Bl.Hi mix.race.Hi.Hi 
          1296            271           2883           1253           1078 
mix.race.Ot.Hi mix.race.Wh.Hi mix.race.Bl.Ot mix.race.Hi.Ot mix.race.Ot.Ot 
           248           2463            253            220             56 
mix.race.Wh.Ot mix.race.Bl.Wh mix.race.Hi.Wh mix.race.Ot.Wh mix.race.Wh.Wh 
           507           2906           2371            515           5516 
> 
>   cat("\nChecking all numeric-to-category race mappings:\n\n")

Checking all numeric-to-category race mappings:

> 
>   # Loop over all combinations (i,j)
>   for (i in 1:4) {
+     for (j in 1:4) {
+       # Construct term names
+       num_term <- paste0("mix.race.num.", i, ".", j)
+       race_term <- paste0("mix.race.", num_to_race[i], ".", num_to_race[j])
+       
+       # Check if both terms exist
+       if (num_term %in% names(race_num_alignment) && race_term %in% names(race_term_alignment)) {
+         # Compare counts
+         num_count <- race_num_alignment[num_term]
+         race_count <- race_term_alignment[race_term]
+         
+         if (num_count == race_count) {
+           cat("Confirmed: (", i, ",", j, ") in race.num = (", num_to_race[i], ",", num_to_race[j],
+               ") in race. Count:", num_count, "\n")
+         } else {
+           cat("Mismatch: (", i, ",", j, ") in race.num = (", num_to_race[i], ",", num_to_race[j], 
+               "). Counts differ: ", num_count, " vs ", race_count, "\n")
+         }
+       } else {
+         # At least one of the terms wasn't found in the alignment vectors
+         cat("Term not found for (", i, ",", j, "): ", num_term, " or ", race_term, "\n")
+       }
+     }
+   }
Term not found for ( 1 , 1 ):  mix.race.num.1.1  or  mix.race.Wh.Wh 
Confirmed: ( 1 , 2 ) in race.num = ( Wh , Bl ) in race. Count: 2883 
Confirmed: ( 1 , 3 ) in race.num = ( Wh , Hi ) in race. Count: 2463 
Confirmed: ( 1 , 4 ) in race.num = ( Wh , Ot ) in race. Count: 507 
Confirmed: ( 2 , 1 ) in race.num = ( Bl , Wh ) in race. Count: 2906 
Term not found for ( 2 , 2 ):  mix.race.num.2.2  or  mix.race.Bl.Bl 
Confirmed: ( 2 , 3 ) in race.num = ( Bl , Hi ) in race. Count: 1253 
Confirmed: ( 2 , 4 ) in race.num = ( Bl , Ot ) in race. Count: 253 
Confirmed: ( 3 , 1 ) in race.num = ( Hi , Wh ) in race. Count: 2371 
Confirmed: ( 3 , 2 ) in race.num = ( Hi , Bl ) in race. Count: 1296 
Confirmed: ( 3 , 3 ) in race.num = ( Hi , Hi ) in race. Count: 1078 
Confirmed: ( 3 , 4 ) in race.num = ( Hi , Ot ) in race. Count: 220 
Confirmed: ( 4 , 1 ) in race.num = ( Ot , Wh ) in race. Count: 515 
Confirmed: ( 4 , 2 ) in race.num = ( Ot , Bl ) in race. Count: 271 
Confirmed: ( 4 , 3 ) in race.num = ( Ot , Hi ) in race. Count: 248 
Confirmed: ( 4 , 4 ) in race.num = ( Ot , Ot ) in race. Count: 56 
> 
> # ## degree distributions
> # inedges <- inedges %>% 
> #   mutate(n_nodes = n*nbprob)
> # outedges <- outedges %>% 
> #   mutate(n_nodes = n*nbprob)
> 
> # negbin_inedges <- negbin_indeg %>% 
> #   mutate(n_nodes = n*nbprob)
> # negbin_outedges <- negbin_outdeg %>% 
> #   mutate(n_nodes = n*nbprob)
> 
> ## distance term
> 
> dist.prop.distribution <- c(15.7, 35.1, 24.1, 22)/100
> dist.nedge.distribution <- edges_target*dist.prop.distribution
> 
> # Save RDS Objects ----
> 
> ## stop()
> 
> 
> # create a list of objects to save
> data_objects <- list(
+   data = data,
+   n0 = n0,
+   edges_only_net = edges_only_net,
+   tgt.old.pctyoung=tgt.old.pctyoung, 
+   tgt.young.pctold=tgt.young.pctold, 
+   tgt.young.pctyoung=tgt.young.pctyoung,
+   edges_target = edges_target,
+   tgt.female.pctmale = tgt.female.pctmale, 
+   tgt.male.pctfemale=tgt.male.pctfemale, 
+   tgt.male.pctmale=tgt.male.pctmale,
+   target_race_num = target_race_num,
+   indegree_data = indegree_data,
+   outdegree_data = outdegree_data,
+   dist_nedge_distribution = dist.nedge.distribution
+ )
> 
> # Print Objects for comparison --------
> edges_only_net
 Network attributes:
  vertices = 32002 
  directed = TRUE 
  hyper = FALSE 
  loops = FALSE 
  multiple = FALSE 
  bipartite = FALSE 
  total edges= 23430 
    missing edges= 0 
    non-missing edges= 23430 

 Vertex attribute names: 
    age age_lb age_started age_ub agecat daily_injection_intensity fraction_recept_sharing hcv_status lat lon race race.num sex syringe_source vertex.names young Zip zipcode 

 Edge attribute names not shown 
> data_objects$tgt.old.pctyoung
[1] 1928.634
> data_objects$tgt.young.pctold
[1] 1910.266
> data_objects$tgt.young.pctyoung
[1] 176332.2
> data_objects$edges_target
[1] 22959.93
> data_objects$tgt.female.pctmale
[1] 6281.835
> data_objects$tgt.male.pctfemale
[1] 6061.42
> data_objects$tgt.male.pctmale
[1] 7576.775
> names(data_objects$target_race_num) <- 
+   c("target.b.w", "target.h.w", "target.o.w",
+     "target.w.b", "target.b.b", "target.h.b", "target.o.b",
+     "target.w.h", "target.b.h", "target.h.h", "target.o.h",
+     "target.w.o", "target.b.o", "target.h.o", "target.o.o")
> data_objects$target_race_num
 target.b.w  target.h.w  target.o.w  target.w.b  target.b.b  target.h.b 
4510.936465 4673.492734 8642.574969  376.083572 2045.729317   45.460651 
 target.o.b  target.w.h  target.b.h  target.h.h  target.o.h  target.w.o 
 438.075369  433.253785  628.413147 2466.814342  788.443825   27.551910 
 target.b.o  target.h.o  target.o.o 
   7.576775    7.576775   36.506281 
> data_objects$negbin_inedges[1:2,]
NULL
> data_objects$outedges[1:4,]
NULL
> data_objects$dist_nedge_distribution
[1] 3604.708 8058.934 5533.342 5051.184
> 
> 
> # Save the list as an RDS file
> saveRDS(data_objects, file = here("fit-ergms", "out", "processed_data.rds"))
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> 
> proc.time()
   user  system elapsed 
 12.377   0.649  17.137 
